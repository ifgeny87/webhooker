# Инструкция для AI ассистента

Давай напишем приложение на nodejs. Будем использовать минимум фреймворков.

Цели: Приложение принимает запросы по http, сравнивает параметры входящего запроса по конфигу, выполняет запуск соответствующих скриптов.

## Флоу

1. Приложение на старте получает путь к конфиг JSON файлу в переменной окружения. Если переменная окружения не задана, то приложение пишет ворнинг в лог и по умолчанию будет искать конфиг в файле config.json. При чтении конфига приложение должно сверить его с zod схемой.
2. В конфиге указан хост (не обязательно, по умолчанию "127.0.0.1") и порт (не обязательно, по умолачнию 3000) листенера для http сервера, и конфигурация для роутов.
3. Приложение ведет лог в JSON формате в stdout.
4. Для http сервера приложения использует либу node:http.
5. При разборе входящих запросов не читается тело запроса.
6. В конфиге есть отдельный раздел для роутов. Каждый роут описывает:
   - http метод (не обязательно, по умолчанию GET)
   - path
   - bearer key (может отсутствовать)
   - как получать bearer key (в header или поле в search в url строке, не обязательно)
   - список команд для выполнения. Для каждой команды описано:
      -- в какой папке надо выполнить команду (не обязательно),
      -- какую команду выполнить,
      -- аргумент или аргументы для запуска команды (не обязательно). Аргументы для запуска могут быть указаны одной строкой или числом или массивом строк или чисел
   - для роута указан общий тайминг для выполнения списка команд (не обязательно, по умолчанию 1 минута)
   - для роута указано, нужно ли возвращать stdout и stderr в теле ответа на запрос (не обязательно, по умолчанию false).
7. Приложение при запуске должно проверить уникальность роутов в конфиге. Уникальность проверяется по методу и path в запросе.
8. Приложение будет получать входящий http запрос. Ищет подходящий роут по method и path. Если такой роут не найден, то возвращает ответ со статусом 404. Если такой роут найден, то проверяет авторизацию по bearer. Если авторизация не проходит, то возвращает 403. При ответе со статусом 404 или 403, тело ответа должно быть пустым.
9. Если bearer не задан или если авторизация пройдена, то метод выполняет команду из указанной папки с указанными аргументами.
10. Для выполнения списка команд назначается таймаут. При достижении этого таймаута выполняется принудительная остановка текущей выполняемой команды. Последующие команды не выполняются.
11. В теле ответа на запрос нужно вернуть json с информацией о выполнении: время старта, время завершения, длительность, статус выполнения команд, сколько команд всего нужно было выполнить, сколько команд выполнено успешно.
12. Если в конфиге для роута указано, что нужно возвращать логи в ответе на запрос, то: в теле ответа на запрос дополнительно нужно приложить массив с логами для каждой выполненной команды. Массив должен влючать папку запуска, команду, аргументы, содержимое stdout, содержимое stderr, длительность выполнения команды.
13. Если для роута назначен список команд, то цепочка команд выполняется в том случае, если каждая предыдущая команда завершилась со статусом 0.
14. Приложение получает входящий запрос, присваивает ему унимальный uuid код. После отправки ответа на запрос приложение логирует входящий запрос. Указывает метод, path, время получения запроса, длительность выполнения запроса, статус ответа.
15. В debug режиме приложение логирует весь процесс запуска команд для проута: путь запуска, команда запуска, аргументы, sdtout, stderr, время запуска, время завершения, длительность работы команды, код выхода команды.
16. Приложение должно отслеживать команды от операционной системы для завершения работы, логировать эти события и мягко завершать работу. Для мягкого завершения должно быть указано время 5 секунд.
17. Если приложение получает повторную команду на закрытие, то оно должно немедленно завершиться с соответствующим логом.
18. Приложение должно достаточно подробно логировать о своей работе.

## Логгер

1. Пишет логи в json формате.
2. В логах всегда есть поля: метка времени (ISO-8601), pid запущенного приложения, уровень лога (DEBUG, INFO, WARN, ERROR, FATAL), компонент (это имя класса или метода, который пишет лог).
3. После старта приложение пишет информацию о среде запуска: OS (название и версия), ОЗУ, место на диске, рабочая папка, команда запуска, аргументы запуска, версия ноды, pid, название приложения и версию из package.json.
4. Уровень лога задается переменной окружения LOG_LEVEL. Если переменная не задана, то по умолчанию выставляется уровень INFO и выводится ворнинг в лог.
5. Логгер должен иметь методы для логирования ошибок типа unknown.
6. Логгер должен иметь методы для логирования дополнительных данных в виде объекта.
7. Если указана переменная окружения LOG_DIR, то логгер должен включить режим записи в файл. В этой переменной указывается папка куда логгер будет писать свои файлы. Если папка не существует, то логгер попытается ее создать.
8. Если логи пишутся в файл, то они пишутся в файлы до определенного размера. После чего начинается запись в новый файл лога.
9. Каждый файл лога должен иметь имя приложения и дату начала записи в этот файл. Таким образом при каждом старте приложение открывает новый файл лога.
10. Если задана переменная окружения LOG_FILE_SIZE_KB то она содержит размер лога в килобайтах. По умолчанию размер одного файла лога 1 мегабайт. Как только файл лога достигает этого размера, то логгер начинает писать в новый файл.

## Инструменты

1. typescript
2. mocha для тестов
3. node:http для создания http сервера
4. editorconfig: максимальная длина строки = 80, табы для кода, пробелы для конфигов и md
5. eslint
6. Скрипты для билда
7. Скрипты для генерации Docker image

## Code style

1. Импорт js и ts модулей без расширений файла.
2. Одиночные апострофы для строк где возможно.
3. Трейс логи и дебаг логи нужно писать от 1го лица, с эмоджиками. Например: "Стартую сервис", "Проверяю файлы", "Проверил, файлы в порядке".
4. Другие уровни логов нужно писать от 3го лица. Например: "Сервис запускается", "Выполняется чтение конфигурации".
5. В логах для входящих запросов и исходящих ответов можно опустить сообщение если нет ошибки. Например: {method:"GET", path:"/api", status: 404, uuid: "...", startedAt: "...", lengthMs: 300}.
6. Используй ООП.
7. Добавь русское описание для классов, методов и функций.
8. Добавь в корне проекта ридми файл с описанием проекта.
9. Для работы с метками времени используй более точные измерения с микросекундами. Например: добавь хелпер, который будет возвращать текущее время так: `performance.timeOrigin + performance.now()`.

## Что нужно сделать

1. Установить необходимые модули. Использовать npm. Модули должны использоваться с конкретными версиями.
2. Написать код приложения по слоям в папке src.
3. Создать папку env для разных сред запуска: разработка, тестовый стенд, продуктовый стенд. Для каждой среды создать подпапку и в ней примеры конфигов.
4. Написать тесты:
   - Добавить файлы тестов в папку tests.
   - В папке тестов должны быть свои файлы конфигов (арматуры) для тестирования приложения.
   - В тестах добавить оценку покрытия для папки src.
   - Написать столько тестов, чтобы покрытие кода тестами было не менее 95%.
   - Тесты должны запускаться из папки tests. Но при этом тесты должны запускать приложение из папки сборки.
5. Головной скрипт запуска приложения назови main.ts. Он использует другие модули и выполняет только три пункта: загружает конфиг, создает логгер, создает и запускает веб листенер.
6. Добавить модуль semantic release для выполнения релиза:
   - релиз нужен только для размещения релизных файлов в github releases
   - публиковать в npm не нужно
7. Связи и порядок запуска скриптов:
   - Сборка должна выполняться в папке build. Перед сборкой нужно очищать папку сборки и выполнять линтинг папки исходных файлов.
   - Тесты должны запускаться после сборки. Файлы тестов не должны билдиться.
   - Релиз выполняется только после тестов.
